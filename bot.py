import asyncio
from datetime import datetime, timedelta
import os

from apscheduler.schedulers.asyncio import AsyncIOScheduler

from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup, LinkPreviewOptions
from telegram.constants import ParseMode
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackContext, ContextTypes, MessageHandler, filters, CallbackQueryHandler

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, select, delete, insert

import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

TOKEN = os.environ.get("TOKEN")
DATABASE_URL = os.environ.get("DATABASE_URL")

engine = create_async_engine(DATABASE_URL, echo=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
Base = declarative_base()

scheduler = AsyncIOScheduler()

lessons = [
    {"title" : "Lektion 1. –õ–∏—á–Ω—ã–µ –º–µ—Å—Ç–æ–∏–º–µ–Ω–∏—è", "link": "https://t.me/c/2054418094/48?thread=43"},
    {"title" : "Lektion 2. –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –ª–∏—á–Ω—ã—Ö –º–µ—Å—Ç–æ–∏–º–µ–Ω–∏–π", "link": "https://t.me/c/2054418094/56?thread=52"},
    {"title" : "Lektion 3. –ì–ª–∞–≥–æ–ª sein (–±—ã—Ç—å)", "link": "https://t.me/c/2054418094/64?thread=58"}
]

main_keyboard = ReplyKeyboardMarkup([
    [KeyboardButton("üìã –£—Ä–æ–∫–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è")],
    [KeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")]
], resize_keyboard=True)

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    chat_id = Column(Integer, unique=True)
    schedule = Column(String, default='everyday 08:00')

class Reminder(Base):
    __tablename__ = 'reminders'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    lesson_index = Column(Integer)
    remind_at = Column(DateTime)

def schedule_checker(application):
    # job_id = f"reminder_{user_id}"
    # scheduler.remove_job(job_id=job_id, jobstore=None) if scheduler.get_job(job_id) else None
    # scheduler.add_job(
    #     send_lesson,
    #     'interval',
    #     days=interval_days,
    #     start_date=datetime.now().replace(hour=hour, minute=minute, second=0) + timedelta(days=0),
    #     args=[chat_id, user_id, context],
    #     id=job_id,
    #     replace_existing=True
    # )
    #
    # initialise using all registered users and their schedules
    scheduler.add_job(check_reminders, "interval", days=1, args=[application])
    scheduler.start()

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    async with async_session() as session:
        result = await session.execute(select(User).where(User.chat_id == chat_id))
        user = result.scalar_one_or_none()
        if not user:
            user = User(chat_id=chat_id)
            session.add(user)
            await session.commit()
            await session.refresh(user)

            reminder = Reminder(user_id=user.id, lesson_index=0, remind_at=datetime.now())
            session.add(reminder)
            await session.commit()

    await show_today_lessons(update, context)

async def show_today_lessons(update: Update, context : ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    async with async_session() as session:
        result = await session.execute(select(User).where(User.chat_id == chat_id))
        user = result.scalar_one_or_none()
        if not user:
            await update.message.reply_text("–¢—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ù–∞–ø–∏—à–∏ /start")
            return

        result = await session.execute(
            select(Reminder.lesson_index).where(
                Reminder.user_id == user.id,
                Reminder.remind_at <= datetime.now()
            )
        )
        logger.info(f"result: {result}")
        indices = sorted(set(row[0] for row in result.fetchall()))
        logger.info(f"indices: {indices}")

        if not indices:
            await update.message.reply_text("–ù–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–µ—Ç —É—Ä–æ–∫–æ–≤ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.")
            return

        await update.message.reply_text("üìã –£—Ä–æ–∫–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:")
        for idx in indices:
            if 0 <= idx < len(lessons):
                lesson = lessons[idx]
                await show_lesson(update, lesson)


async def show_lesson(update, lesson):
    msg = f"<a href='{lesson['link']}'>{lesson['title']}</a>"
    keyboard = build_keyboard()
    await update.message.reply_text(msg, parse_mode=ParseMode.HTML, reply_markup=keyboard,
                                    link_preview_options=LinkPreviewOptions(is_disabled=True))


async def show_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    async with async_session() as session:
        result = await session.execute(select(User).where(User.chat_id == chat_id))
        user = result.scalar_one_or_none()

        if not user:
            await update.message.reply_text("–¢—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ù–∞–ø–∏—à–∏ /start")
            return

        await update.message.reply_text("–ü–æ–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–æ")
        await update.message.reply_text(f"–¢–µ–∫—É—â–µ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ: –¥–ª—è user.id={user.id}, chat_id:{user.chat_id}, schedule: {user.schedule}")
        await update.message.reply_text(f"{scheduler.get_jobs()}")


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"update:{update}, context: {context}")

    text:String = update.message.text.lower()

    if "—É—Ä–æ–∫–∏" in text and "—Å–µ–≥–æ–¥–Ω—è" in text:
        await show_today_lessons(update, context)
    elif "—É—Ä–æ–∫–∏" in text and "–≤—Å–µ" in text:
        await show_all_lessons(update, context)
    elif "—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ" in text:
        await show_schedule(update, context)
    else:
        await update.message.reply_text("–ù–µ –ø–æ–Ω–∏–º–∞—é. –í—ã–±–µ—Ä–∏ –∏–∑ –º–µ–Ω—é.")

def build_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("‚èÆ –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º", callback_data="next_lesson"),
            InlineKeyboardButton("‚è≠ –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–∫", callback_data="prev_lesson"),
            InlineKeyboardButton("‚úÖ –ü—Ä–æ—à–µ–ª, –±–æ–ª—å—à–µ –Ω–µ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å", callback_data="next_lesson")
        ],
        [
            InlineKeyboardButton("üîÅ –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 1–¥", callback_data="remind_1"),
            InlineKeyboardButton("üîÅ —á–µ—Ä–µ–∑ 2–¥", callback_data="remind_2"),
            InlineKeyboardButton("üîÅ —á–µ—Ä–µ–∑ 3–¥", callback_data="remind_3")
        ]
    ])

# async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     query = update.callback_query
#     user_id = query.from_user.id
#     await query.answer()
#
#     if query.data == "next_lesson":
#         user_data[user_id]["lesson_index"] += 1
#         await send_lesson(query.message.chat_id, user_id, context)
#
#     elif query.data == "prev_lesson":
#         user_data[user_id]["lesson_index"] -= 1
#         await send_lesson(query.message.chat_id, user_id, context)
#
#     elif query.data == "remind_later":
#         keyboard = InlineKeyboardMarkup([
#             [InlineKeyboardButton("–ß–µ—Ä–µ–∑ 1 –¥–µ–Ω—å", callback_data="remind_in_1")],
#             [InlineKeyboardButton("–ß–µ—Ä–µ–∑ 2 –¥–Ω—è", callback_data="remind_in_2")],
#             [InlineKeyboardButton("–ß–µ—Ä–µ–∑ 3 –¥–Ω—è", callback_data="remind_in_3")]
#         ])
#         await query.edit_message_reply_markup(reply_markup=keyboard)
#
#     elif query.data.startswith("remind_in_"):
#         days = int(query.data.split("_")[-1])
#         schedule_reminder(user_id, query.message.chat_id, interval_days=days, context=context)
#         await context.bot.send_message(chat_id=query.message.chat_id, text=f"üìÖ –•–æ—Ä–æ—à–æ! –ù–∞–ø–æ–º–Ω—é —á–µ—Ä–µ–∑ {days} –¥–Ω–µ–π.")
#
# def schedule_reminder(user_id, chat_id, interval_days, context, hour=8, minute=0):
#     job_id = f"reminder_{user_id}"
#     scheduler.remove_job(job_id=job_id, jobstore=None) if scheduler.get_job(job_id) else None
#     scheduler.add_job(
#         send_lesson,
#         'interval',
#         days=interval_days,
#         start_date=datetime.now().replace(hour=hour, minute=minute, second=0) + timedelta(days=0),
#         args=[chat_id, user_id, context],
#         id=job_id,
#         replace_existing=True
#     )

async def send_lesson_by_user(user, reminder, context):
    index = reminder.lesson_index
    if 0 <= index < len(lessons):
        lesson = lessons[index]
        msg = f"üìò –ü—Ä–æ–π–¥–∏ —É—Ä–æ–∫ <a href='{lesson['link']}'>{lesson['title']}</a>"
        keyboard = build_keyboard()
        await context.bot.send_message(chat_id=user.chat_id, text=msg, reply_markup=keyboard, link_preview_options=LinkPreviewOptions(is_disabled=True), parse_mode=ParseMode.HTML)


async def check_reminders(context: CallbackContext):
    now = datetime.now()
    async with async_session() as session:
        result = await session.execute(select(Reminder).join(User).where(Reminder.remind_at <= now))
        reminders = result.scalars().all()
        for reminder in reminders:
            user = await session.get(User, reminder.user_id)
            await send_lesson_by_user(user, reminder, context)
            await session.commit()

async def hello(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(f'–ü—Ä–∏–≤–µ—Ç {update.effective_user.first_name}!')

async def show_all_lessons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(f"üìö –í—Å–µ —É—Ä–æ–∫–∏ –∫—É—Ä—Å–∞:")
    for idx, lesson in enumerate(lessons):
        msg = f"<a href='{lesson['link']}'>{lesson['title']}</a>"
        keyboard = build_keyboard()
        await update.message.reply_text(msg, parse_mode=ParseMode.HTML, reply_markup=keyboard)

async def main():
    await init_db()
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("today", show_today_lessons))
    app.add_handler(CommandHandler("hello", hello))
    app.add_handler(CommandHandler("all", show_all_lessons))
    app.add_handler(CommandHandler("schedule", show_schedule))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    schedule_checker(app)

    await app.initialize()
    await app.start()
    await app.updater.start_polling()

    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
